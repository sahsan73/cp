# 1043. Partition Array for Maximum Sum
Problem Statement: <https://leetcode.com/problems/partition-array-for-maximum-sum/description/>   

&nbsp;
&nbsp;

### Implementation: Top - Down (Recursion + Memoization)
```cpp
class Solution {
private:
    int maxSumAfterPartitioning(vector<int> &arr, int k, int i, vector<int> &dp) {
        int n = (int)arr.size();
        if(i >= n)
            return 0;
        if(~dp[i])
            return dp[i];
        
        int mx = 0, res = 0;
        for(int j = i; j < min(i + k, n); ++j) {
            mx = max(mx, arr[j]);
            res = max(res, mx * (j-i+1) + maxSumAfterPartitioning(arr, k, j+1, dp));
        }
        return dp[i] = res;
    }

public:
    int maxSumAfterPartitioning(vector<int> &arr, int k) {
        vector<int> dp(arr.size(), -1);
        return maxSumAfterPartitioning(arr, k, 0, dp);
    }
};
```

### Implementation: Bottom - Up (Iteration + Tabulation)
```cpp
class Solution {
private:
    int maxSumAfterPartitioning(vector<int> &arr, int k, int i, vector<int> &dp) {
        int n = (int)arr.size();
        if(i >= n)
            return 0;
        if(~dp[i])
            return dp[i];
        
        int mx = 0, res = 0;
        for(int j = i; j < min(i + k, n); ++j) {
            mx = max(mx, arr[j]);
            res = max(res, mx * (j-i+1) + maxSumAfterPartitioning(arr, k, j+1, dp));
        }
        return dp[i] = res;
    }

public:
    int maxSumAfterPartitioning(vector<int> &arr, int k) {
        int n = (int)arr.size();
        vector<int> dp(n+1, 0);
        for(int i = n-1; ~i; --i) {
            int mx = 0;
            for(int j = i; j < min(i+k, n); ++j) {
                mx = max(mx, arr[j]);
                dp[i] = max(dp[i], mx*(j-i+1) + dp[j+1]);
            }
        }
        return dp[0];
    }
};
```
